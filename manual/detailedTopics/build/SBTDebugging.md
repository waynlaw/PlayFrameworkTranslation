# 빌드 디버깅하기

여러분이 수행하고자 하는 것에서 sbt를 사용하는데 어려움을 격고 있다면 sbt가 여러분의 빌드를 도와주고자 기본으로 내장된 유틸리티를 사용할 수 있을 것이다.

## 의존성 디버깅하기

기본적으로 sbt는 여러개가 요청되었을 때 sbt가 어떤 버전의 의존성을 선택할지에 대해 보여주는 충돌 해결 표와 의존성이 다른 의존성을 가져오는 것을 타행적으로 보여주는 의존성 트리를 포함하여 모든 의존성에 대한 보고서를 생성한다.

이 보고서는 XSL 스타일시트도 동봉하여 xml 파일으로 생성된다. 이 XSL 스타일시트는 HTML으로 XML 보고서를 변환하는 것을 지원한다. 이를 지원하는 브라우저는 파이어 폭스와 사파리를 포함하고, 특히 크롬이 포함되어 있지 않습니다.

보고서는 여러분의 `target/resolution-cache/reports` 디렉터리에서 찾을 수 있으며, 여러분의 프로젝트에서 각각의 스코프를 위해 하나가 생성되고, 예를들어 `com.example-my-first-app_2.11-compile.xml` 처럼 `organization-projectId_scalaVersion-scope.xml`로 이름이 정해진다. 파이어폭스로 열게 되면, 보고서는 다음과 같이 나타난다.

[[images/ivy-report.png]]

## 설정 디버깅하기

sbt가 제공하는 빌드를 이해하는데 사용할 수 있고 틀린 부분을 발견할 수 있는 몇몇 유용한 명령어가 있다.

### show 명령어

show 명령어는 어떤 sbt 태스크로부터 반환 값을 보여준다. 그래서 예를 들어 소스 파일이 정말 컴파일 되었는지 안 되었는지 확실하지 않다면 `show sources`를 수행하여 sbt가 sources에 포함한 것을 살펴볼 수 있다.

```
[my-first-app] $ show sources
[info] ArrayBuffer(my-first-app/app/controllers/Application.scala, 
  my-first-app/target/scala-2.11/twirl/main/views/html/index.template.scala,
  my-first-app/target/scala-2.11/twirl/main/views/html/main.template.scala,
  my-first-app/target/scala-2.11/src_managed/main/routes_reverseRouting.scala,
  my-first-app/target/scala-2.11/src_managed/main/routes_routing.scala,
  my-first-app/target/scala-2.11/src_managed/main/controllers/routes.java)
```

위의 결과는 스크린에 형식에 맞춰 적절하게 보여지며, 여러분이 수행한 태스크가 수 많은 항목을 반환하면 이를 확인하기 위해 에디터로 복사할 수도 있다.

또한 `test:sources`나 `compile:sources` 처럼 특정 스코프를 명시하거나 특정 프로젝트를 `my-project/compile:sources`처럼 명시할 수도 있다. 또한 몇몇의 경우 다른 태스크로부터 태스크가 스코프되어 있다면 스코프 역시 명시할 수 있다. 예를들어 여러분의 jar 파일으로 묶일 모든 것을 살펴보기 위해 `packageBin`태스크로 스코프 되어있는 `mapping` 태스크를 다음과 같이 살펴볼 수 있다.

```
[my-first-app] $ show compile:packageBin::mappings
[info] List(
  (my-first-app/target/scala-2.11/classes/application.conf,application.conf),
  (my-first-app/target/scala-2.11/classes/controllers/Application.class,controllers/Application.class),
  ...
```

### inspect 명령어

inspect 명령어로 태스크에 대한 정의 되어 있는 곳과 의존성 정보를 포함한 자세한 정보를 살펴볼 수 있다. `show` 명령어 처럼 사용할 수 있다.

```
[my-first-app] $ inspect managedSources
[info] Task: scala.collection.Seq[java.io.File]
[info] Description:
[info] 	Sources generated by the build.
[info] Provided by:
[info] 	{file:my-first-app/}root/compile:managedSources
[info] Defined at:
[info] 	(sbt.Defaults) Defaults.scala:185
[info] Dependencies:
[info] 	compile:sourceGenerators
[info] Reverse dependencies:
[info] 	compile:sources
...
```

여기 `managedSources` 명령어로 검토한 결과가 있다. 결과는 우리에게 파일의 시퀀스를 제공하는 태스크에 대해서 알려주고 있으며, `Sources generated by the build.`라는 설명을 가지고 있다. `sourceGenerators`에 의존성이 있고, `sources` 태스크에 의존하고 있음을 살펴볼 수 있다. 또한 어디에 정의되어 있는지 확인할 수 있으며, 이 경우에는 sbt의 기본 태스크 정의의 185번째 라인에 정의되어 있음을 알 수 있다.

### inspect tree 명령어

inspect tree 명령어는 특정 태스크를 위한 태스크의 전체 의존성 트리를 보여준다. 만약 `unmanagedSources` 태스크를 위한 트리를 검토하면 다음과 같은 내용을 볼 수 있다.

```
[my-first-app] $ inspect tree unmanagedSources
[info] compile:unmanagedSources = Task[scala.collection.Seq[java.io.File]]
[info]   +-*/*:sourcesInBase = true
[info]   +-*/*:unmanagedSources::includeFilter = sbt.SimpleFilter@3dc46f24
[info]   +-compile:unmanagedSourceDirectories = List(my-first-app/app, my-first-a..
[info]   | +-compile:javaSource = app
[info]   | | +-*:baseDirectory = my-first-app
[info]   | |   +-*:thisProject = Project(id root, base: my-first-app, configurations: List(compile,..
[info]   | |   
[info]   | +-compile:scalaSource = app
[info]   |   +-*:baseDirectory = my-first-app
[info]   |     +-*:thisProject = Project(id root, base: my-first-app, configurations: List(compile,..
[info]   |     
[info]   +-*:baseDirectory = my-first-app
[info]   +-*/*:excludeFilter = sbt.HiddenFileFilter$@49e479da
```

이 트리는 파일이 포함되는지 제외되는지 결정하는 필터를 포함하여 여러분의 프로젝트에서 sbt가 소스를 발견하기 위해 사용하는 태스크의 전체 트리를 보여준다. `inspect tree` 명령어는 빌드의 일부가 어떻게 구조화 되어있는지 확신이 없거나 깊이 있게 모든 것이 적절하게 어울리고 있는지 확인하길 원할 때 아주 유용하게 사용할 수 있다. 

## 증가하는 컴파일 디버깅 하기

플레이에서 사람들이 갖는 공통 문제는 플레이가 예상한대로 동작하지 않을때 다시 컴파일하고 다시 로드하는 방법을 찾게 된다. 이런 문제는 보통 리로드를 강제하거나 IDE가 부주의하게 플레이의 클래스패스의 요소를 갱신하거나 소스 생성자에 의해서 발생한다. 이런 문제를 디버깅하기 위해서 컴파일 태스크의 디버그 로그를 살펴볼 수 있다. sbt가 태스크를 실행할 때 로그가 표시되든 되지 않든 상관없이 모든 로그 결과물을 캡쳐하며 따라서 나중에 원한다면 로그를 검토해 볼 수 있다. `last` 명령어를 사용하여 이 로그를 검토해 볼 수 있다.

`compile`이라는 명령을 내려야 하고, 파일을 다시 컴파일할 필요가 있다.

```
[my-first-app] $ compile
[info] Compiling 1 Scala source to my-first-app/target/scala-2.11/classes...
[success] Total time: 1 s, completed 07/04/2015 1:28:43 PM
```

`last compile`을 수행하는 것으로 컴파일 명령어 동안 어떤 얼이 발생했는지에 대한 전체 디버그 로그를 얻을 수 있다. 이는 많은 결과를 외부장치로 복사하지만 첫 번째 부분이 우리들이 관심이 있는 부분이며 다음과 같이 나타난다.

```
[my-first-app] $ last compile
[debug]
[debug] Initial source changes:
[debug] 	removed:Set()
[debug] 	added: Set()
[debug] 	modified: Set(my-first-app/app/controllers/Application.scala)
[debug] Removed products: Set()
[debug] External API changes: API Changes: Set()
[debug] Modified binary dependencies: Set()
[debug] Initial directly invalidated sources: Set(my-first-app/app/controllers/Application.scala)
[debug]
[debug] Sources indirectly invalidated by:
[debug] 	product: Set()
[debug] 	binary dep: Set()
[debug] 	external source: Set()
```

이 것이 우리에게 알려주는 것은 `my-first-app/app/controllers/Application.scala`가 수정되었기 때문에 재컴파일이 실행되었다는 것이다.
