<!--- Copyright (C) 2009-2015 Typesafe Inc. <http://www.typesafe.com> -->
# 플레이 문서 작성을 위한 가이드라인

플레이 문서는 마크다운 형식으로 작성되었고 코드 샘플은 소스 파일을 컴파일하고 실행하고 테스트하도록 추출되어있다.

다음은 플레이 문서를 작성할 때 참고해야 하는 가이드라인이다.

## 마크다운

모든 마크다운 파일은 어떤 폴더에 있는지와 관계없이 전체 문서에서 유니크한 이름을 가져야 한다. 플레이는 문서를 렌더링하고 연결하는데 위키 스타일을 사용한다.

단락의 중간에 있는 줄바꿈 문자열은 GitHub 형식의 마크다운과 유사하게 하드 랩으로 간주되어 라인 브레이크로 렌더링 된다. 따라서 단락은 한줄에 포함되어야 한다.

### 링크

문서에서 다른 페이지로의 링크는 위키 마크업 문법을 사용하여 생성해야 한다.

    [[Optional description|ScalaRouting]]

이미지 또한 위의 문법을 사용해야 한다.

> 외부 링크는 위의 문법을 사용할 수 없다. 그러나 대신 표준 마크다운 링크 문법을 사용해야 한다.

## 코드 샘플

모든 지원되는 코드 샘플은 외부 컴파일된 파일으로 부터 이입되어야 한다. 다음과 같은 문법을 사용한다.

    @[some-label](code/SomeFeature.scala)

파일은 추출될 필요가 있는 라인의 범위를 정하기 위해 `#some-label`를 사용할 수 있다.

```scala
object SomeFeatureSpec extends Specification {
  "some feature" should {
    "do something" in {
      //#some-label
      val msg = Seq("Hello", "world").mkString(" ")
      //#some-label
      msg must_== "Hello world"
    }
  }
}
```

위의 경우 ``val msg = ...``는 추출되어질 것이며 페이지의 코드로 렌더링 될 것이다. 모든 코드 샘플은 확실하게 컴파일이 되고, 실행되는지 확인되어야 하며, 만약 의미가 있는 경우 문서에서 말하고자 하는 것이 무엇인지 확실히 해야 하며, 이 기능 자체를 테스트하려고 해서는 안된다.

모든 코드 샘플은 동일한 클래스로더에서 실행하자. 결과적으로 그것과 관계가 있는 문서의 일부에 부합하는 패키지 내에 적절한 네임스페이스를 가져야 한다.

몇몇의 경우 위의 가이드라인에서 알려준대로 여러분이 작성할 수 있는 코드가 문서와 정확하게 매치되어 나타나지 않을 수도 있다. 특히 일부 코드 샘플은 `controllers`라는 패키지 이름의 사용을 필요로 한다. 최후의 수단으로 이를 위한 다른 방법이 없으면 다음의 명시된 지시자를 코드에 넣어서 코드 샘플 추출자에게 샘플에 대한 수정사항을 지시할 수 있다.

* `###replace: foo` - 다음 라인을 `foo`로 수정한다. 이 명령어를 `###`로 종료할 수도 있다.
* `###insert: foo` - 다름 라인 전에 `foo`를 삽입한다. 이 명령어를 `###`로 종료할 수도 있다.
* `###skip` - 현재 라인을 건너 뛴다.
* `###skip: n` - 다음 n개의 라인을 건너 뛴다.

예를 들면 다음과 같다.

```scala
//#controller
//###replace: package controllers
package foo.bar.controllers

import play.api.mvc._

object Application extends Controller {
  ...
}
//#controller
```

> 이 지시자는 오직 최후의 수단으로 사용해야 한다. 왜냐하면 외부의 파일으로 내려받은 코드 샘플은 문서의 코드와 동일하게 컴파일되고 테스트될 것이기 때문이다. 지시자를 사용하면 이는 실패한다. 

물론 코드 샘플의 현재 컨텍스트를 알고 있는 것도 중요하다. 적절한 import 구문도 문서화 되어야 함을 명심하자. 그러나 모든 코드 샘플에서 모든 import 구문이 포함될 필요가 있음을 의미하는 것은 아니며 재량에 의해서 여기에 표시되어야 한다.

특정 타입의 코드 샘플에 대한 가이드라인은 아래와 같다.

### 스칼라

모든 스칼라 코드 샘플은 specs를 사용하여 테스트되고 코드 샘플은 가능하면 spec 안에 있어야 한다. 로컬 클래스나 메소드 정의는 적절하게 위치시키기를 권장한다. 블록 내에 import 문의 범위를 정하는 것도 또한 권장된다.

### 자바

모든 자바 코드 샘플은 JUnit 을 사용하여 테스트되어야 한다. 간단한 코드 샘플은 보통 JUnit 테스트 내에 포함될 정도로 간단하며 코드 샘플이 메소드나 클래스일 경우엔 어려울 수 있다. 선호하는 것은 로컬이나 내부 클래스를 사용하여 보여주는 것이며 예를들어 static 메서드가 static 내부 클래스에 있는 것 처럼 이 방법이 불가능할 수 있다. 그러나 외부 클래스인 경우에는 나타나지 않는 클래스에 static 수정자를 추가하는 것을 의미한다. 따라서 몇몇의 경우 자바 코드 샘플을 그들 파일의 외부로 빼낼 필요가 있을 수도 있다.

### 스칼라 템플릿

스칼라 템플릿 코드 샘플은 자바의 JUnit이나 스칼라의 Specs처럼 테스트되어야 한다. 템플릿은 기본 imports와 다르게 컴파일되며 자바 문서나 스칼라 문서가 무엇인지에 따라 의존성이 있음을 명심하자. 그러므로 또한 적절한 형식으로 테스트되는 것이 중요하며 만약 템플릿이 자바 스레드 로컬에 의지한다면 자바 액션으로부터 테스트되어야 한다.

가능하다면 템플릿 코드 샘플은 한 파일로 통합되어야 한다. 그러나 예를들어 코드 샘플이 파라미터 정의를 포함한다면 항상 가능하지는 않을 것이다.

### 라우트 파일

스칼라 템플릿 코드 샘플은 자바의 JUnit이나 스칼라의 Specs처럼 테스트되어야 한다. 라우트 파일은 예를들어 `scalaguide.http.routing.routes`처럼 모든 패키지 이름으로 명명되어야 하며 다른 라우트 코드 샘플으로 부터 분리되어야 함을 보장해야 한다.

문서에서 사용하는 라우트 컴파일러는 해당 파일에 의해 선언 된 네임 스페이스 내부의 리버스 라우터를 생성하는 특수 모드에서 실행됩니다.
이는 라우트 코드 샘플일지라도 클래스로 절대적인 참조값을 사용하여 나타낼수도 있으며, 이 라우터의 네임스페이스는 실제로 상대적인 것이 된다. 따라서 위의 라우트 파일은 만약 `controllers.Application`라는 라우트를 가지고 있다면 실제로는 `scalaguide.http.routing.controllers.Application`라는 컨트롤러를 가리키게된다.

### SBT 코드

현재 SBT 코드 샘플은 문서의 외부로 뽑아낼 수 없다. 왜냐하면 컴파일하고 이를 수행하기 위해 완전 다른 클래스로더나 클래스 패스를 사용하는 별도의 SBT 설정이 요구되기 때문이다.

### 다른 코드

다른 코드는 테스트가 되거나 되지 않을 수 있다. HTMLUnit을 사용하여 통합테스트를 수행하여 자바스크립트 코드를 테스트할 수 있을 수도 있고. 이를 로딩하여 테스트 환경설정을 할 수도 있다.

## 문서 테스트하기

문서를 빌드하기 위해 먼서 플레이를 로컬에 빌드하고 발행할 필요가 있다. 플레이 프레임워크 저장소의 `framework` 디렉터리 내에서 `./build publishLocal`을 사용하여 할 수 있다.

문서가 적절하게 렌더링 되는 것을 확인하기 위해 `documentation` 디렉터리 내에서 `./build run`을 수행하자. 작은 플레이 서버가 실행되어 문서를 제공해 줄 것이다.

코드 샘플이 컴파일되고 실행되고 테스트를 통과하는 것을 확인하기 위해 `./build test`를 수행하자.

문서가 구조적으로 잘 되었는지 검증하기 위해 `./build validateDocs`를 수행하자. 이는 잘못된 위키 링크나 잘못된 코드 참조나 리소스 링크가 없는지 모든 문서 마크다운 파일이 유니크한지 부모를 잃은 페이지가 없는지 확인한다.

## 외부 플레이 모듈의 코드 샘플

선형 의존성을 회피하기 위해 플레이의 핵심 부분이 아닌 플레이 모듈에서 문서화된 문서는 플레이 문서의 나머지 부분과 함께 코드 샘플을 포함할 수 없다. 이를 참조하기 위해 모듈을 위한 문서는 `project/Build.scala`에 `externalPlayModules` 맵으로 위치할 수 있고, 모든 추가적인 설정을 포함하는 것은 모듈을 위한 코드 조각으로 빌드될 필요가 있다.

```scala
val externalPlayModules: Map[String, Seq[Setting[_]]] = Map(
  "some-module" -> Seq(
    libraryDependencies += "com.example" %% "some-play-module" % "1.2.3" % "test"
  ),
  ...
)
```

이제 `code-some-module`에서 모듈을 사용할 모든 코드 조각을 위치시켰다. 이제 모듈이 포함되는 것을 보장하여 SBT 명령어를 수행하기 위해 `./build -Dexternal.modules=some-module test`를 수행하거나 모든 모듈을 위한 테스트를 수행하기 위해 `./build -Dexternal-modules=all test`를 수행하자.

